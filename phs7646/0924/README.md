시간 안에 해결한 문제 : 1,2,3,4

# 문제 요약

### 1번

정렬 + 구현

### 2번

구현
최근 받은 값과 다른 값이 나오면 그 동안의 값을 전부 현재 인덱스로 출력

### 3번

정렬
정렬된 상태에서 (0 to i) + (i+1 to N-1) 의 그룹으로 나누는 모든 경우의 수 탐색

### 4번

게임이론 + 그리디

# TIL

3번 까지는 정말 빠르게 풀면서 실력이 많이 늘었다고 생각했다.

### 4번

게임이론 문제고 생각할 거리가 정말 많았다. 설명하기 굉장히 힘들지만 요약하자면

bottom-up으로 "반드시 부를 수 있는 수" 를 찾아봤는데, 2,6은 kali가 부를 수 있고, 8이하의 남은 수들은 Ringo가 부를 수 있다.

9이상의 수들은 top-down으로 다음과 같은 두가지 점화식으로 "이기는 수" 와 "지는 수"로 분리할 수 있다.

"지는 수" {a | a+b="이기는 수" && a%b==0}
"이기는 수" {a | a + b = "지는 수" for all b where a%b==0}

9이상의 모든 수에 대해 "이기는 수"는 2와 6이 아닌 5,7,8 로 수렴한다.. 따라서 2,6만 Kali가 이길 수 있는 수이다.
