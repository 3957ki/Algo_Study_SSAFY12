시간 안에 해결한 문제 : 1,2,3,4

# 문제 요약

### 1번

DP 로 계산

### 2번

DP[i] = i번을 반드시 골랐을 때 최댓값
DP[i] = max(DP[k] for A[k] > A[i]) + A[i]

### 3번

백트래킹으로 바이러스 위치 정하고 bfs

### 4번

bfs를 기본으로 하는 다양한 구현

# TIL

### 3번

문제를 처음 읽고, 생각하는 동안 입력 범위와 문맥을 통해 어느정도 DP임을 예상했지만, 5분 정도 생각하는 동안 그렇다 할만할 아이디어가 떠오르지 않았다. 초조해지려는 찰나에 그냥 4번 먼저 풀었는데, 4번 풀고 오니 바로 DP 아이디어가 생각났다.

DP문제는 앞으로도 너무 오래 고민하지말고 다른 문제로 환기 시켜가며 아이디어를 떠올리는게 좋을 것 같다.

최초 answer 값을 0또는 1로 초기화 해야하는데, 이부분을 빠뜨려서 예제는 전부 맞았지만 2번이나 제출이 fail이 됐다. 정말 사소한 실수지만 코딩 테스트 실전에서 일어나면 찾아내기도 쉽지 않고 정말 허무하게 한문제를 날려야한다. 앞으로 더 더 주의해야겠다.

### 4번

문제에서 요구하는 알고리즘이 중력, 회전, bfs 로 한문제 치고는 굉장히 다양했다.

문제 자체는 어느정도 최적화가 모자라도 패스할 것 처럼 보였지만, 그래도 최적화를 열심히 진행해보니 visited 배열만 3개를 사용하게 되었다. 그래도 잘 디자인된 것 같다.

문제 구현량이 많아 문제를 천천히 읽고, 각 단계별로 시작부터 디버깅 코드를 넣어가면서 천천히 진행했다. 어느정도 디버깅을 예상했는데 오히려 천천히 작성해서 그런지 한번만에 통과할 수 있었다.

