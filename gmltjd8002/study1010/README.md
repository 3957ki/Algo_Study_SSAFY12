시간 안에 해결한 문제 : 1,2
추가 해결한 문제 : 3

# 문제 요약

### 1번

자료구조

### 2번

dp, LIS

### 3번

구현

### 4번

# TIL

### 1번

map과 set중에 고민했던 문제이다.
map은 key와 value로 인과관계 설정이 필요할 때 좋지만 여기에선 인과관계가 크게 필요없을 것 같았다.
집합에 ChongChong이 들어오는 그 이후부터 트리거가 활성화가 되었던 것 같고, set을 사용했던 것 같다.
left와 right를 분리해서 이미 집합에 해당 이름들이 있다면 둘 다 집합에 넣어줬다.
set은 중복을 제거해주므로 기존의 값을 넣어줘도 무리가 없었다.

### 2번

처음에는 단순하게 구현할 생각을 했다.
값들을 StringTokenizer로 받은 다음 prev와 after를 비교했다.

```pseudo
prev -> st.nextToken()
while(st.hasMoreTokens()){
  while(prev <= after){
   cnt++;
   prev -> 이전 값으로 덮어씌우기
  }
}
```

위의 형태로 구현하려고 했는데, 여러 문제가 있었다.
배열을 선언하지 않아서 이전 값을 받아올 방법에 대해 생각하지 못했고,
배열을 사용한다고 해도 for문을 통해 인덱스를 도출할텐데, 비효율적인 연산이 많이 들어갈 것 같았고, 로직을 폐기했다.
남아있는 병사의 수가 최대가 되게 하고 싶다는 글을 보고 dp를 생각하게 되었다.
dp를 통해 dp[i]와 dp[j]+1을 비교하면 될 것 같다고 생각했다.
dp만으로 코드를 작성했고 오답판정을 받은 후, 다시 문제를 들여다보았다.
저번에 배웠던 LIS가 불현듯 생각이 났고, dp와 LIS를 접목했던 것 같다.
다만 다른점은 LIS는 최장증가부분수열이지만 이 문제는 최장감소부분수열이라고 할 수 있다.
이 부분만 유의해서 진행했고, 정답 판정을 받았다.

### 3번

시작지점과 맵을 주고, 최대값을 찾는 구현 문제였다.
문제에서 URDL의 순서로 방향을 줬기에 해당 방향 순서대로 탐색을 진행하였다.
무한루프를 돌 수 있는 경우도 있었는데, 이 경우를 구현하는 부분이 제일 오래 걸렸다.
해당 배열을 방문했는지 확인해야 무한루프를 확인할 수 있으므로 사용하였는데,
각 좌표마다 진입방향이 4방향으로 달랐기에 3차원 방문배열을 사용했다.
다른 dfs나 bfs에서의 경계값 체크처럼 경계값을 벗어나거나 블랙홀인 C지점에 도달하면 종료시켰다.
이미 방문했던 배열에 도달했다면 해당 루프는 무한루프이므로 return을 통해 코드를 종료시켰다.
예전에 SWEA에서 풀었던 달팽이 회전과 비슷한 방법으로 방향을 지정해 가독성을 높이고 싶었다.
하지만 구현의 한계로 임의로 방향을 지정해줬다.
기존에 무심코 사용하던 방문배열을 새로운 방식으로 쓸 수 있다고 느꼈던 것 같다.
