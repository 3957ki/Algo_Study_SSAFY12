시간 안에 해결한 문제 : 1,2
추가 해결한 문제 : 

# 문제 요약

### 1번

구현

### 2번

dp

### 3번


### 4번



# TIL

### 1번
푸는데 거의 한 시간은 걸렸던 것 같은 문제다.
같은 크기의 배열을 만들어서 각각의 페어 수를 저장했다.
연립방정식의 느낌으로 다가갔던 것 같고, 미지수를 하나씩 구해나가며 소거시키는 느낌이었던 것 같다.
res 배열이 항상 0 이상이라고 생각해 조건문을 달지 않았고, 여기서 꽤 시간이 오래걸렸다.
물론 가장 시간이 오래 걸린 부분은 배열에 값을 넣는 부분이다.
푸는데 시간은 오래 걸렸지만 흥미로운 문제였다.

### 2번
처음엔 1,-1,2를 이용해 부분집합을 이용할까 고민했는데 문제자체의 로직도 그렇고 숫자의 크기를 봤을 때 접근이 틀렸다는걸 바로 눈치챘고, dp로 방향을 잡았다.
//
생각해본점
i번째에 도달할 수 있는점은
i-1에서 1칸 이동
i-2에서 2칸 이동인데
  - i-2에 도달하기 위해선 i-1에서 한칸 뒤로 이동했다는 말이 된다
  - i-1에서 뒤로 한칸 이동했다 -> i-3에서 두칸 뛰었다!
  - (i-3) -> (i-1) -> (i-2)로 이동했다는 의미이다. 이걸 하나의 사이클로 간주했다.
점화식 : dp[i] = dp[i-1] + dp[i-3];

값이 int를 넘어갈 것 같아 dp배열을 long으로 선언해줬고, n이 3이하인 경우 따로 예외처리를 해주었다.
머리로는 로직을 이해했는데 말로 설명하려니 말문이 막혔고, 아직 dp를 완전히 이해하진 못했다고 생각했다.

### 3번
