시간 안에 해결한 문제 : 1,2
추가 해결한 문제 : 3

# 문제 요약

### 1번

정렬 및 그리디

### 2번

정렬 및 그리디

### 3번

dp

### 4번



# TIL

### 1번
각 배열의 x와 y좌표의 값을 따로 받아왔다. 받아온 다음 각각의 중앙값을 구해 임의로 위치를 지정했다.
빅데이터분석기사나 대학교 교양 때 중앙값의 중요성에 대해 수업을 들었었고, 해당 문제에 접목할 수 있었을 것 같다.
처음엔 직관적으로 생각했고, 각 맨하탄거리의 평균을 구해볼까도 생각했다. 하지만 이상치에 영향을 크게 받을 것 같아 방향을 바꿨다.
처음에 제출했을 때 오답이 나왔는데, 테스트케이스 1번에도 나와있듯, 음수의 경우에는 절대값을 취해준 다음 값을 더해줘야한다.
하지만 더해준 다음 절대값을 취했고, 오답이 나왔었다. 
그리고 또 답이 틀렸었는데, int의 범위를 벗어나는 값이 충분히 나올 수 있었는데, int형으로 선언해 값이 틀렸다.
저번에도 이런 실수를 해서 시간을 많이 날렸는데, 이번에는 그나마 빨리 알아차린 것 같아서 다행이다. 물론 처음부터 체크하는 습관을 들이는게 제일 좋은 것 같다.
### 2번
이 문제도 정렬을 한 후에 문제를 풀었다.
/*
 * 품질 -> 묶음의 median으로 결정
 * 짝수인 경우 -> (n/2)+1
 * 홀수인 경우 -> (n+1)/2 
 * (ex) 6개라면
 * 1 2 3 4 5 6 -> 6/2+1 = 4번째(4) -> 중앙에서 오른쪽걸로 취급
 * (ex) 5개라면
 * 1 2 3 4 5 -> 5+1/2 = 3번째(3) -> 그냥 가운데거임
 * --------------------------------------------------
 * 1. 부분집합 만들기
 * 2. 그 부분집합에서 중앙값을 이용해 가격 책정하기
 * 3. 기저부분에서 최대값 갱신하고 출력하기...
 * -> 꼬여서 포기
 * 가장 낮은 등급의 소를 가장 비싼 소와 묶으면 비싸진다(짝수개면 오른쪽걸로 취급)
 * a.k.a 가우스 합?
 * 97프로...
 * */ 
 작성했던 주석인데, 진행하다 코드가 너무 복잡해져 포기하고, 다시 접근방법부터 다시 바꿨다.
 처음엔 1~3번까지 구현하는데 부분집합을 사용했다. 코드가 상당해져서 포기했다.
 그 이후로 문제를 조금 들여다보니 가장 높은 등급의 소와 가장 낮은 등급의 소를 매칭하는게 제일 비싸겠다는 생각이 들었다.
 그 이후 해당 경우들에 홀수와 짝수인경우를 나눠서 생각했는데, 짝수는 반복분 안에서 완벽하게 계산이 끝난다.
 홀수인 경우는 가운데 친구가 혼자 남기 때문에 그 친구는 혼자 팔아야하고, 반복문을 나와서 별도로 더해줘서 구현했다.
 인덱스를 설명하는 부분이 조금 헷갈려 두번정도 fail이 떴던 것 같다.
 주석에 나와있는 97프로도 중간인덱스인 n/2를 출력해야하는데 (n/2)+1를 출력해 틀렸던 것 같다.
### 3번
 시간내에 풀진 못했지만 추가로 해결한 문제이다.
 문제만 봤을 땐 부분집합으로 구현이 가능해 보였지만, dp로 푸는게 더 나을 것 같다는 생각을 했다.
 dp의 큰 틀은 외웠기에 대부분의 큰 틀은 작성까지 오래 걸리진 않았다.
 세부적인 인덱스를 조절하는데 더 오랜 시간이 걸린 것 같다.
 배열이 인덱스를 벗어나기도 하고, 원하지 않는 값이 나왔기에 페어에게 도움을 요청했다.
 도움을 받고나서 배운 점은 아래와 같다.
 1. dp 배열만 n+1로 받지 말고 map 배열도 n+1로 받는게 좋다
 2. dp는 기존값과 현재 조건을 만족하는 값중 더 좋은 조건의 값을 고르는 과정이다 -> 이 과정을 생각하며 인덱스를 잘 보자.
 3. 동일한 조건의 경우 더 가치있는 부분을 가져오기 위해 끝에서 부터 값을 넣을 수도 있다.
 4. 이 문제는 1차원 dp로 구현이 가능하다.
 
