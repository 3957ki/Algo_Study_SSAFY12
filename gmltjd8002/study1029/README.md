시간 안에 해결한 문제 : 1,2
추가 해결한 문제 : 

# 문제 요약

### 1번

dfs

### 2번

다익스트라

### 3번



### 4번

# TIL

### 1번

처음엔 dp를 생각했었다.
예전에 풀었던 문제 중 한 칸을 이동하거나, 두 칸을 이동하는 dp 문제가 있었던 것을 생각했고,
dp로 방향을 잡은 채로 진행했다.
그런데 문제를 읽다 보니 dp라고 하기엔 수상한점이 한 두 개가 아니었다고 느꼈다.
문제를 다시 읽어봤고, 그래프탐색으로 방향을 잡았다.
dfs 파라미터에 최적의 값을 계속 갱신하며 탐색을 진행했다. 
부분집합처럼 1인경우와 2인경우로 나눠서 각각 dfs를 돌렸고, 정답으로 인정받았다.
dp와 생각보다 헷갈려서 시간을 지체했던 문제고, 문제를 조금 더 꼼꼼하게 봐야겠다.


### 2번

인접행렬을 가장 먼저 떠올렸던 문제다.
인접행렬을 이용해 백트래킹을 이용해 풀어볼까 생각했다.
```
1.a와 b 입력 받기
2.배열 순회하기
   2-1. b값이 없다 -> 바로 -1 출력 후 리턴
   2-2. b값이 있다
      2-2-1. b값이 있는 경우 a값 저장
      2-2-2. 위의 a값이 새로운 b값이 되는 경우가 있는지 확인
      2-2-3. 이거 반복하면서 값 갱신
3. res 출력
``` 
초기 로직은 이렇게 생각했었는데, 로직이 생각보다 복잡해보여서 다른 방법을 찾아봤다.
문제 중 인접행렬과 값이 모두 양인 가중치를 가지며 최소라는 단어를 보며 다익스트라를 떠올렸다.
우선순위 큐와 compareTo를 오버라이딩해서 비용순으로 정렬 해 주었다.
코드를 정리할 때 다른 스터디원의 풀이를 보니 bfs가 정해였던 것 같다.
그래도 간만에 다익스트라를 풀어봐서 좋았다.
### 3번
