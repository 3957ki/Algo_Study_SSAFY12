시간 안에 해결한 문제 : 1,2
추가 해결한 문제 : 

# 문제 요약

### 1번

정렬 및 그리디

### 2번

dfs 및 백트래킹

### 3번



### 4번



# TIL

### 1번
문제를 보자마자 그리디라는 생각이 들었다. 처음 계획은 비싼 순으로 내림차순 정렬 후 i%3 == 2인값들은 0으로 바꾼 다음 반복문을 통해 값을 합하는 것이었다.
하다 보니 내림차순으로 정렬하는 방법을 까먹었고, 오름차순으로 정렬 후 역순으로 카운트하는 방법도 고려했다.
하지만 이 방법은 배열 개수%3 값이 얼마냐에 따라 취급해야 할 인덱스가 달라진다는 점을 알았다.
길이를 구해서 나머지 연산을 통해 조건문을 걸어 반복문을 돌리는 생각도 했지만 정해가 아닌 것 같아서 그만뒀다.
reverse까지만 쳐보고 Ctrl + space를 해봤는데 Comparator를 포함한 람다 추천식이 눈에 띄었고, Comparator.reverseOrder()를 기억해 낼 수 있었다.
아쉬운 점은 cnt를 증가시키다가 3이되면 continue를 하는 것보다 i%3 == 2 인경우를 생각하는게 조금 더 정해가 아니었나 싶다.

### 2번
처음 문제를 접했을 땐 주어진 String에서 좌우만 비교하는 문제인 줄 알았고, 스택이나 완전탐색을 생각했다. 그런데 4번 테스트케이스가 매우 큰 수가 나왔음을 뒤늦게 확인했고, 접근방법이 달랐음을 느꼈다. 문제를 다시 읽어보니 해당 문자열의 각 알파벳들을 조합해 경우의 수를 만드는 순열이었고, dfs와 백트래킹이 좋을 것 같다고 느꼈다.
char형태로 선언되는 경우에 ascii코드는 무조건 나오는 것 같다는 느낌도 들었다.
수업시간에 풀이해주신 내용 중 alphabet에 해당되는 인덱스를 ++연산하는 풀이가 있었는데, 접근방법이 흥미로워서 관심있게 봐뒀었는데, 여기서 쓰게 되었고, 만족스럽다.
dfs부분을 구현할 때 idx 이외에 temp라는 char를 만들었는데, 결론부터 말하면 운이 조금 따라줬던 것 같다.
위에서 char 형태가 많이 나와 은연중에 char로 선언한 부분이 없지않아 있는데, 현재 인덱스를 기준으로 이전 값(알파벳 한글자) 만을 요구하므로 String 형태로 선언할 필요가 없다.
그리고 이 문제의 특이점은 다른 dfs 및 순열 문제와 달리 방문처리를 해주는 배열이 없는 대신, 알파벳 인덱스를 갱신해서 그 역할을 대신해줬다고 생각한다. char 형태가 나온다면 ascii코드를 주로 사용하고, 알파벳을 배열에 받아오는 부분은 익혀두길 잘한 것 같다고 생각했다.