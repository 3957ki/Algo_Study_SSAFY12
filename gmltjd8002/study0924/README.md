시간 안에 해결한 문제 : 1
추가 해결한 문제 : 2

# 문제 요약

### 1번

구현

### 2번

구현

### 3번

이분탐색

### 4번



# TIL

### 1번
처음에 문제를 잘못 읽어 중복이 없는 줄 알고 트리셋과 keyset, Entry, for-each를 써서 구현하려 했는데 당연히 오답판정을 받았다.
문제를 다시 봤는데, 중복이 있을 수 있다고 해서 이차원 배열로 방향을 다시 잡았다. 람다를 이용해 도착시간을 기준으로 정렬을 해주고
현재 시간과 소의 도착 시간을 비교해 현재 시간이 더 작다면 소의 도착시간에 검문시간을 더해주었다.
현재 시간이 더 큰 경우는 앞의 소를 검문하고있는데 뒤에 소가 도착한 경우가 있고, 이 때는 현재 시간에 검문시간만 더해주면 되는 문제였다.
람다식과 로직이 크게 어렵지는 않은 문제였다.

### 2번
시간내에 풀지는 못한 문제이다.
완전탐색으로 앞에서부터 시도를 해봤던 문제인데, 값의 범위를 보니 무조건 터지겠다고 생각했다.
그래서 최적화를 조금 진행한 코드는 다음과 같다.
```java
for(int i=1;i<=n;i++){ // n번 탐색
            boolean flag = false;
            for(int j=i+1;j<=n;j++){
                if(map[i] != map[j]){
                    flag = true;
                    sb.append(j).append(" ");
                    break;
                }
            }
            if(!flag) sb.append(-1).append(" ");
        }
        ```
flag를 만들어 값을 만족하면 sb에 값을 추가하고 루프를 빠져나왔다.
이 코드의 가장 큰 문제점으론 불필요한 추가탐색이 있을 수 있다는 점이다.
이렇게 작성한 후 제출해 봤는데 역시 시간초과가 발생했다.
다른 스터디원의 풀이를 봤는데, 기존과 다른값이 들어오면 그 이전 값들이 정해진다는 풀이가 가장 정해같았고, 그 로직을 생각하며 코드를 구현했다.
그리고 앞에서 탐색하는 것 보단 뒤에서 탐색하는게 좋아보여서 뒤에서부터 탐색을 진행했고, 정답판정을 받았다.

### 3번
