시간 안에 해결한 문제 : 1,2
추가 해결한 문제 : 

# 문제 요약

### 1번

분할정복

### 2번

dp

### 3번


### 4번



# TIL

### 1번
분할정복 문제였다. 기존 분할정복들은 특정 조건을 만족할 때 까지 끝까지 파고들어가는 문제들이 많았다.
이번 문제는 약간 달랐던게 끝까지 파고들어가지않고 그 직전의 값을 구하는 것이 목표였다.
분할정복이라는 것을 알아차리고, 핵심 로직작성까지 크게 오래걸리진 않았다.
그런데 두번째로 작은 값을 저장하는 부분에 대해서 생각을 해보았다.
if -else 구문으로 재귀를 계속 실행해 n이 1이 되거나 처음부터 1인 경우에는 바로 그 값을 출력했다. 4등분한 값들을 재귀를 통해 걸러내 배열에 저장했고, 그 값들을 정렬해서 두번째 작은값을 출력했다. 분할정복을 빠르게 캐치해서 나름 빠르게 풀어낼 수 있었다.

### 2번
알고리즘을 캐치해내는데도 오래 걸렸고, 그 알고리즘을 구현하는데도 오래 걸렸던 문제다.
처음에는 arraylist에 1 + n-2 + 1로 구현하고, n-2에서 2씩 빼주고 양옆에 1씩 더해주고,
양옆 수들이 2이상이면 그자리에서 1을 빼주고, 반대편 인덱스에 1을 더해주는 로직을 생각해봤다. 이런 경우에는 관리해야하는 인덱스 개수가 너무 많고, 로직자체도 복잡하며, 수치가 커지면 바로 시간초과가 날 것 같았다. 그래서 이것도 분할정복일지 고민을 해보았는데 아니었다.
다시 처음 로직을 들여다봤는데 1 + n-2 + 1 이 부분에서 n-2부분은 작은 여러 케이스로 나눠서 계산할 수 있다고 생각했고, dp를 생각해냈다. dp로직을 구현하는데도 오래걸렸다.
양옆 수를 반복문을 통해 늘리는 방법을 생각했는데 j의 범위를 안일하게 설정해 j가 오른쪽 인덱스로 넘어가는 부분까지 구현이 되었고, 당연히 틀렸다.
그 부분을 해결하고 정답을 인정받았다. dp는 봐도봐도 어려운 것 같다...

### 3번
