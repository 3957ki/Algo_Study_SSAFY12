시간 안에 해결한 문제 : 1
추가 해결한 문제 : 2

# 문제 요약

### 1번

구현

### 2번

구현

### 3번



### 4번



# TIL

### 1번
문제를 접했을 때 길이도 엄청 짧았고, 크게 로직에 대한 부분이 있는 것 같지 않았다.
따라서 구현으로 방향을 잡았다.
행 및 열의 개수에 대해서 먼저 들여다보았다. 1일때 1, 2일때 5, 3일때 9임을 확인했고, 등차수열임을 확인했다
처음 접근했던 방법에 대해서 간단하게 적어보려고 한다.
- 배열을 절반으로 나눈다음 행이 절반 이하인 경우와 이상인 경우를 나눠 반복문을 돌린다
- 가장 왼쪽과 가장 오른쪽에는 *을 출력한다.
- 가운데 1+4(n-1) -2 개 만큼의 별을 출력한다.
- 위의 크기에 같은 만큼의 공백을 출력한다.
- 1+4(n-1) -2 -2 만큼에 공백을 출력한다.
-....
생각하다 오래걸려서 포기했던 로직이다.
다시 보니 특정 규칙이 있었고, 그걸 생각해봤는데 액자식으로 코드가 구현이 된다는 걸 알았다.
그래서 재귀를 이용한 구현으로 방향을 잡게 되었다. 한 점에서 다음 재귀로 이동할 때 x로 2, y로 2만큼 이동한다는 걸 알았고, 파라미터를 이용해 작성했던 것 같다.
문제는 짧았지만 생각이 더 오래걸렸던 문제인 것 같다.
### 2번
시간내에 풀려고 노력했지만 2%대에서 자꾸 틀린 문제였다.
처음 접근은 작은 길이부터 큰 길이순으로 나무를 잘라보는 경우가 최적해에 더 바람직하다고 생각했다.
큰 합판은 작은합판으로 만들 수 있지만 그 역의 과정은 성립하지 않기 때문이다. 따라서 배열에 입력을 받고 정렬을 하였다. 
처음엔 크게 어렵지 않았지만 작성을 다 했는데 틀렸다는 문구를 많이 봤다.
결론만 먼저 얘기하면, long타입으로 바꾸는 것과 자른 횟수가 아닌 합판의 개수를 기준으로 잡아야 했다.
합판을 자를 때 길이가 나눠 떨어지는 경우와 아닌 경우를 따로 나눠서 생각해줘야 했던 문제였다.
그리고 비용이 int타입을 넘을 수 있다는 생각을 하지도 못했다.
처음에는 크게 어려운 문제는 아닌 것 같다고 느꼈지만 생각보다 어려웠던 것 같다.