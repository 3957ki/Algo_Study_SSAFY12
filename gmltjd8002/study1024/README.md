시간 안에 해결한 문제 : 1,2
추가 해결한 문제 : 3

# 문제 요약

### 1번

자료구조

### 2번

슬라이딩 윈도우

### 3번

애드혹

### 4번

# TIL

### 1번

접근법으로 가장 먼저 큐가 떠올랐다.
EOF 처리를 해 줘서 값을 받아줘야하는 문제였고,
값이 0이면 큐를 하나 비워줘야하고, 버퍼가 꽉차면 입력을 받을 수 없다
이 두 경우 이외의 값은 큐에 오퍼한다
처음엔 버퍼 용량 초과 -> 0으로 로직을 처리했고, 50점을 받았다.
다시 생각해보니 0이라는 값이 들어오면 큐를 비워줘야하기 때문에 우선순위가 높다
그리고 큐가 비어있는경우 문자열을 출력해야한다는 부분도 빼먹었다.
위에 개선사항을 고치고 정답처리를 받았다.
다른 스터디원들의 실행시간과 메모리를 보니 정해가 아닐수도 있지만 직관적으로 잘 푼 것 같다.
### 2번

n의 크기가 그렇게 크지 않았고, 완탐을 생각했다.
1번부터 시작해 2번,3번을 시작으로 k개의 신호등을 살펴봐야하므로 슬라이딩 윈도우로 방향을 다시 잡았다.
1번부터 시작해 고쳐야하는 신호등의 개수를 미리 저장해두고, 시작값을 늘리며 고쳐야하는 신호등의 개수를 갱신했다.
아직 슬라이딩 윈도우에 익숙하지 않아서 그런지 생각보다 오래 걸렸던 문제다.

### 3번

n의 크기가 약간 컸지만 처음엔 dfs와 백트래킹을 생각했던 것 같다.
dfs와 백트래킹으로 스왑을 해보고 두 문자열이 같은 경우 값을 출력하려 했지만, 시간초과가 발생했다.
코드를 작성하고 다시 보다보니 그리디도 생각했다.
현재 문자열은 한번 지나가면 다시 돌아오지 않으므로 다르다면 무조건 바꿔야했다.
해당 로직으로 풀었을 때 시간초과가 날 것 같진 않았지만 값이 다르게 나왔다.
결국 시간안에 풀지는 못했지만, 스터디가 끝나고 마저 고민해봤다.
정해가 애드혹이라는 풀이를 듣고 애드혹에 대해 찾아보고 다시 문제를 봤다.
현재 문제에선 a와 b의 개수가 같아야하고, 한 문자를 기준으로 정렬하는 방법을 사용하는게 효율적이었다.
로직이 도저히 생각나지 않아 다른 사람의 코드를 참조하며 풀었던 문제라 아쉬움은 조금 남는다
나중에 다시 풀어봐야겠다.
