시간 안에 해결한 문제 : 1,2
추가 해결한 문제 : 

# 문제 요약

### 1번

유니온 파인드 및 구현

### 2번

dfs

### 3번



### 4번



# TIL

### 1번
문제를 읽으며 이해하는데 시간이 더 걸렸던 문제인 것 같다.
유니온파인드에 대한 개념을 배운것도 오래되지 않았을 뿐더러, 문제도 자주 접한적이 없었다.
테스트케이스를 풀어가며 생각해봤는데 유니온파인드와 비슷하게 접목할 수 있다고 생각했다.
방을 합친다는게 이전의 방에 흡수된다라는 생각이 들었고, 유니온파인드를 생각하게 되었다.
아직까진 유니온파인드에 대한 감이 빠르게 다가오진 않지만 문제를 자주 풀어가며 감을 키워야겠다.
/*
1~N번까지 N개의 방이 있음
x<a<y인 모든 a의 벽을 허물어버린다
이미 무너진방이라면 무시한다
1,N번방은 항상 고정
허물어져 합쳐지고 남은 방의 개수 구하기
M : 벽을 허무는 횟수
N : 동방 개수
1 2 3 4 5
-> 1 1 3 4 5
-> 1 1 1 1 5

-아이디어
유니온 파인드?
서로소였던 집합들이 초기에는 자기자신을 가리킴
이게 벽을 허물면서 같은방이 됨 -> 루트가 같아지는 방법으로 해석이 가능할 것 같다.
유니온 파인드 필요했던 요소
find -> 루트노드를 가리키면 그 값을 반환하고 아니라면 경로압축을 통해 재귀를 호출해 루트를 반환한다
union -> 각 두 값의 루트를 받아서 이 루트가 같으면 이미 같은 노드이고, 아니라면 합치고 헤드부분을 바꿔줬다.
여기선 헤드를 결합한 방으로 보는게 나을 듯 하다
 */
 이건 코드를 작성하며 기록한 주석이다.
### 2번
문제를 보자마자 dfs임을 눈치챘던 것 같다.
중요한 점이 시작점과 끝점이 다르다는 점과, 재귀 횟수를 조심해야 했던 것 같다.
파라미터에 행,열의 좌표를 기존에는 받았지만, 이 문제에선 재귀횟수를 세기 위해 callCnt파라미터를 추가했다.
이 값이 재귀할때마다 1씩 증가하게되고, dfs의 기저부분에서 k값과 같은 경우에만 카운트를 늘려줬다.
가치지기 부분에선 callCnt가 k를 넘는 경우에 바로 루프를 종료하였고, 메모리 성능에 조금이라도 이득을 본 것 같다.