시간 안에 해결한 문제 : 1
추가 해결한 문제 : 3

# 문제 요약

### 1번

구현 및 그래프 탐색

### 2번

누적합

### 3번

이분탐색

### 4번



# TIL

### 1번
예전에 했던 술게임이 생각나는 문제였다.
처음 했던 추측은 중복조합으로 풀 수 있다고 생각했다.
그런데 다시 생각해보니 한사람당 한명만 지목을 할 수 있겠다는 생각이 들었다.
따라서 중복조합은 아니라고 판단했고 다시 문제를 들여다 보았다.
두번째 추측은 bfs나 dfs까진 아니더라도 이미 지목받은 사람의 정보를 방문처리했다.
그리고 이 값이 N과 같은지를 비교하며 카운트 수를 늘렸다.
코드를 짜기 전에 충분히 구상을 한 후 코드를 작성해 오히려 시간을 아낄 수 있었다.
### 2번
시간내에 풀지는 못한 문제이다.
1번과 3번을 먼저 푸느라 건너뛰었고, 다른 스터디원의 풀이를 들었다.
XOR연산들이 가지는 큰 특징을 잘 짚어내서 설명을 해줬던 것 같고, 설명을 듣고 바로 문제를 풀어봤는데 실수를 한 번 했지만 빠르게 문제를 통과 할 수 있었다.
누적합이나 직접 XOR을 구현하는 두가지 방법이 있겠지만, 누적합으로 이전까지항과의 XOR연산결과를 가지고 있는 편이 더 빠르지 않을까 하는 생각에 누적합으로 풀었던 것 같다. 처음 문제를 봤을 땐 이게 뭐지 싶었지만 이제 다시 보니 크게 어려운 문제는 아니었던 것 같다.
### 3번
1번에서 생각보다 빨리 풀어서 3번에 시간을 오래 투자했다.
문제 자체도 생각보다 어려워서 이해하는데도 꽤 오랜시간이 걸렸다.
도저히 이해가 안가 그림판에 그림을 그리며 생각해봤는데, 이분탐색이 생각났다.
말뚝은 완전탐색으로 범위내에 탐색이 가능하지만 깃대는 그렇지 못하다.
깃대를 길이순으로 정렬하고, 말뚝들이 고정된 상태에서 깃대의 높이를 이용해 넓이를 구했다.
이 값을 비교해 깃대의 길이를 조절했다.
다른 이분탐색과 다른점은 다른 이분탐색은 답에 직접적인 영향을 주는 값을 비교하는 문제가 많지만, 이번 문제는 배열에 길이가 들어있고, 이로 인해 인덱스를 이분탐색하는 방향으로 잡았다.
즉, 완전탐색 + 이분탐색이라고 할 수 있다.
구상이 끝나고 구현까지 크게 오래걸리지는 않았다.
하지만 제출을 하고 29%에서 오답판정을 받았고, 혹시나하는 마음에 말뚝들의 길이를 절댓값으로 설정해주었고, 정답판정을 받았다.
말뚝의 길이가 항상 오름차순으로 주어진다는 선입견이 낳은 오답이었다.