시간 안에 해결한 문제 : 1
추가 해결한 문제 : 2

# 문제 요약

### 1번

그리디 -> DP

### 2번

이분탐색

### 3번



### 4번



# TIL

### 1번
처음엔 그리디로 접근했다. 반복문을 돌려 현재 수보다 작은 제곱수 중 가장 큰수를 빼주고, 카운트를 하나 늘려주었다.
일련의 과정을 반복해 카운트의 개수를 출력했고, 샘플 테케도 모두 맞았고 제출을 해보았다.
1%에서 틀렸다고 떴길래 문제에 대해 다시 생각해보았다.
로직에 틀린점은 없었다고 생각했기에 접근방법 자체가 틀렸다고 생각을 해보았다.
최소라는 단어가 자주 보이길래 코드를 다시 봤는데 dp로 접근이 가능할 것 같았다.
dp[i] -> i를 만들되 최소한의 제곱수로 만들 수 있는 배열로 정의하고 접근했다.
기존값은 dp[i] = 1(1로만 채웠을 때, 최악의 경우) 에서 갱신이 가능하다면 갱신하는 방향으로 다시 작성했고, 정답판정을 받았다.
### 2번
처음에 어떻게 접근해야할지 잘 몰랐던 문제다.
접근방법은 몰라도 수학적으로 생각해보았는데, 숫자가 너무 크기도 했고, 팩토리얼 연산자체가 리소스가 많이 든다는 점에서 직접 계산하는 문제는 아니라는걸 느꼈다.
10은 2와 5의 곱이고, 2는 짝수이므로 매우 많이 발생한다. 즉, 5의 개수가 0의 개수를 좌우한다는걸 깨달았다.
문제를 더 들여다 봤을 때 이분탐색이라는 것 까지는 시간내에 알아내었고, 대부분의 로직은 구현했다.
하지만 답이 계속 -1이 나오거나 오버플로가 나는 등이 발생해 코드를 다시 봤다.
이번에도 int를 long으로 바꾸지 않았고, right부분의 값이 너무 컸던 것 같고, 가장 중요한 메서드를 선언하고 파라미터를 넘겼는데, 파라미터를 일치시키지 않았다.
그래서 메서드를 아예 순회하지 않았고, 값이 이상하게 나왔음을 확인했다.
이분탐색을 많이 해 보지도 않았을 뿐더러, 잔실수가 많아 시간이 많이 걸렸던 것 같다.