## 1번 (EOF처리 도움 받음)
- 완전탐색으로 문제를 풀었다.
- 테스트 케이스의 개수가 정해지지 않아서 당황했지만, 스터디원한테 EOF처리 도움을 받아서 해결했다.
  - ```
    String s = "";
    while ((s = br.readLine()) != null) {}
    ```
    위와 같은 방법으로 EOF를 처리할 수 있었다.
- boolean 배열로 방문처리를 통해 중복값을 알아냈다.
- 해당 숫자를 10으로 나눈 나머지 값을 방문처리 하면서 답을 구했다.

다른 풀이를 살펴보니 문자열로 값을 입력받고, 문자에 각각 접근해서 방문처리를 하는 방법을 많이 사용했다.
어떤 방법이 더 좋은지 알아보아야겠다.
쉽게 풀 수 있었지만 EOF 처리 때문에 잘 풀리지 않았다.
까먹지않고 꼭 알아두도록 하자.

## 2번 (문제 이해 실수)
- 시작하는 블럭의 높이가 1이상 1000이하이므로, 1부터 증가시켜가면서 바꿔야하는 블럭의 수를 찾았다.
- 각 블럭은 K크기 간격으로 일정하게 증가하는 형태이어야 한다.
- 블럭 배열을 순회하면서 인덱스와 K값을 활용해, 갖추어야하는 블럭 높이를 구했다.
- 변경이 필요한 블럭이라면 count를 증가시켰고, 가능한 count중에서 최소값을 도출했다.

문제에서 인접 블럭은 K간격만큼 차이가 난다고하여, 증가와 감소가 번갈아가면서 나타날 수 있다고 접근했다.
그래서 초반에는 가능한 경우의 수를 나누어 BFS로 답을 찾았었다.
하지만 문제에서 주어진 점화식을 보면, 다음 인덱스의 블럭은 무조건 이전 블럭보다 높아야 한다는 것을 알 수 있었다.
문제가 헷갈리게 알려준 부분도 있지만 문제를 꼼꼼하게 봐야할 필요성을 느꼈다.
매우 아쉬웠기 때문에 다음부터는 이런 실수가 없도록 해야겠다.

## 3번


## 4번

