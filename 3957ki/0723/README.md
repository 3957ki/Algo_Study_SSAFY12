## 1번 (EOF처리 도움 받음)
- 완전탐색으로 문제를 풀었다.
- 테스트 케이스의 개수가 정해지지 않아서 당황했지만, 스터디원한테 EOF처리 도움을 받아서 해결했다.
  - ```
    String s = "";
    while ((s = br.readLine()) != null) {}
    ```
    위와 같은 방법으로 EOF를 처리할 수 있었다.
- boolean 배열로 방문처리를 통해 중복값을 알아냈다.
- 해당 숫자를 10으로 나눈 나머지 값을 방문처리 하면서 답을 구했다.

다른 풀이를 살펴보니 문자열로 값을 입력받고, 문자에 각각 접근해서 방문처리를 하는 방법을 많이 사용했다.
어떤 방법이 더 좋은지 알아보아야겠다.
쉽게 풀 수 있었지만 EOF 처리 때문에 잘 풀리지 않았다.
까먹지않고 꼭 알아두도록 하자.

## 2번 (문제 이해 실수)
- 시작하는 블럭의 높이가 1이상 1000이하이므로, 1부터 증가시켜가면서 바꿔야하는 블럭의 수를 찾았다.
- 각 블럭은 K크기 간격으로 일정하게 증가하는 형태이어야 한다.
- 블럭 배열을 순회하면서 인덱스와 K값을 활용해, 갖추어야하는 블럭 높이를 구했다.
- 변경이 필요한 블럭이라면 count를 증가시켰고, 가능한 count중에서 최소값을 도출했다.

문제에서 인접 블럭은 K간격만큼 차이가 난다고하여, 증가와 감소가 번갈아가면서 나타날 수 있다고 접근했다.
그래서 초반에는 가능한 경우의 수를 나누어 BFS로 답을 찾았었다.
하지만 문제에서 주어진 점화식을 보면, 다음 인덱스의 블럭은 무조건 이전 블럭보다 높아야 한다는 것을 알 수 있었다.
문제가 헷갈리게 알려준 부분도 있지만 문제를 꼼꼼하게 봐야할 필요성을 느꼈다.
매우 아쉬웠기 때문에 다음부터는 이런 실수가 없도록 해야겠다.

## 3번
- 큐를 사용한 BFS로 해결했다.
- 이 문제에서는 양과 늑대가 울타리안에 갇혀있기 때문에, 배열 밖을 탐색하는 경우는 고려할 필요가 없다.
- 차례대로 배열을 순회하며 양이나 늑대가 나오면 BFS를 시작했다.
- 방문처리는 boolean배열로 했다.
- 4방탐색하면서 .을 만나면 그대로 큐에 넣었고, 늑대나 양이 나오면 각 동물의 개수 증가 후 큐에 넣었다.
- 각 울타리 안에서 동물별 개수에 따라 살아남는 동물의 개수를 더해주었다.

이 문제를 풀면서 고민했던 부분은 4방탐색을 했을 때 경우의 수를 어떻게 나눌지 고민을 했다.
좌표값을 어떻게 큐에 넣을까 고민하다가 Node클래스를 만들어서 해결했다.
아직 BFS문제에 익숙하지않아서 시간이 오래걸렸다.
자주 나오는 유형이므로 많이 풀어보면서 익숙해져야겠다.

## 4번

