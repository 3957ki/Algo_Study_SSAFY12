## 1번
- 원하는 가격을 오름차순으로 정렬하고, DFS로 해결했다.
- 임시 가격을 원하는 가격 배열을 기준으로 점차 증가시켜가며 탐색했다.
- 원하는 가격이 임시 가격보다 작지 않고, 임시 가격이 배송비보다 크면 총 이익을 증가시켰다.
- 가격별 얻는 총 이익중 최대값으로 갱신했다.

원하는 가격과 배송비를 2차원 배열로 저장했기때문에 정렬기준을 원하는 가격으로 하도록 Comparator를 설정했다.
람다식을 처음 활용해보았는데 편리했다.
처음엔 조금 어렵게 느껴졌으나 나름 수월하게 풀었다.

## 2번
- HashMap을 사용하여 루프의 개수를 탐색했다.
- HashMap을 사용하면 String으로 다음 사람을 빠르게 탐색할 수 있다.
- keyset을 뽑아낸 다음 배열로 생성하여 모든 사람을 순회했다.
- 다음 사람을 탐색할 때 마다 HashMap에서 해당 key, value를 지웠다.
- 다음 사람이 없거나, 처음 사람을 다시 만난다면 return하여 루프를 구했다.

처음엔 HashMap을 사용할 생각을 못해서 Node클래스를 만들어서 자신의 이름과 마니또 이름을 저장했다.
하지만 HashMap을 이용하면 상수시간에 원하는 값에 접근이 가능하므로 훨씬 효율적이다.
그리고 HashMap에서 해당 key가 있는지 확인하는 contains 메서드는 배열과 달리 상수시간에 확인 가능하다.
다음 사람의 존재여부를 contains로 확인하면 더 좋을 것이다.
PS에서 HashMap을 자주 사용해보지 않아서 익숙하지 않았다.
좋은 자료구조이므로 사용가능한지 항상 생각해보자.

## 3번 (힌트 도움 받음)
- 이진 탐색으로 해결했다.
- 게이트별 소요시간을 기준으로 오름차순으로 정렬했다.
- 가장 소요시간이 긴 게이트에 모두가 줄을 서는 경우가 최대 소요시간이다.
- 1부터 최대 소요시간까지를 범위로 잡고 이진 탐색을 진행했다.
- 탐색한 소요시간에 통과 가능한 인원이 적다면 시간을 늘리고, 크거나 같다면 여유가 있으니 시간을 줄여가며 탐색했다.
- low와 high가 교차되었을 때 마지막으로 탐색한 소요시간에 모두 통과할 수 없다면 시간을 1증가한 값을 출력했다.

모두 통과 가능한 시간을 찾았더라도, 이 시간은 최소시간이 아닐 수 있었다.
해당 상황을 생각 못해서 많이 틀렸다.
그래서 통과 가능한 시간을 찾아도 계속해서 탐색하는 방법으로 low와 high가 교차될 때 까지 탐색했다.
이진탐색할 값을 어떤 것으로 정할 지 생각을 못했고, 탐색 범위를 정하는 것도 몰랐었다.
스터디원이 그 부분을 알려주어서 해결했다.
이진탐색을 배열에서 값을 찾는 것에만 사용을 했어서, 이 문제처럼 응용하는 실력을 길러야겠다.

## 4번
