## 1번
- DP를 이용해서 쉽게 풀었다.
- 처음에 DP함수 호출 시작 파라미터를 n으로 하고 재귀로 풀었더니 시간초과가 나왔다.
- 그래서 반복문으로 처음 숫자부터 n까지 차례대로 갱신하여 해결했다.

DP문제에 많이 취약하다는 것을 알게되었고, 같은 유형의 문제를 많이 풀어서 익숙해져야겠다고 생각했다.

## 2번(도움 받음)
- DP를 이용해서 풀었다.
- 처음에 DP값에 자신을 포함하지 않아도 최대값이 되는 수를 저장했다.
- 그랬더니 반례가 있었고 그 반례를 알아내지 못하여서 많이 헤맸다.
- DP값에 무조건 자신을 포함하는 최대값으로 저장했고, 따로 max변수를 두어서 그 값들 중 max값을 저장했다.

DP값에 무엇을 넣어야하는지 알아내는 것이 어려웠다.
조건에 맞춰 점화식을 명확하게 세울 필요성이 있었고, 여러가지 반례를 떠올리는 것이 중요했다.
DP유형에서 많이 고전해서 기본적인 문제부터 차례차례 많이 풀어봐야겠다.

## 3번(일부 도움 받음)
- DFS와 BFS 모두 사용하여 해결했다.
- 주어진 map 테두리를 1로 패딩하여 벽을 만들었고, 2값을 받아 올 때 마다 virus리스트에 저장했다.
- virus 리스트 중 가능한 조합을 DFS로 탐색했고, 탐색한 값을 이용해서 BFS로 4방탐색을 진행했다.
- BFS 과정에서 해당 노드까지 소요되는 시간을 배열로 저장했고, 탐색하지 않은 빈 공간이 있을경우 바로 return했다.
- 모든 빈 공간을 탐색했다면, 소요되는 시간 중 max값을 result값과 비교해서 최소값을 result에 저장했다.
- 각 조합별 소요시간 중 최소 시간을 구할 수 있다.

구현양이 생각보다 많고, DFS에 익숙하지 않아서 오래걸렸다.
일부 테스트 케이스에서 많이 오류가 났다.
놓친 예외 중 하나는, 각 위치별 전파 소요시간을 제대로 저장하지 못했다.
탐색한 위치에 탐색 기준 위치의 값 + 1을 해주는 방식으로 해결했다.
그리고 나머지 예외 하나는, 바이러스 위치 조합을 구했을 때 조합으로 선정되지 않은 바이러스 후보 위치를 간과했다.
조합에 선정되지 않은 위치도 빈 공간으로 인식해서 탐색하는 코드로 수정해서 풀 수 있었다.
DFS 문제를 많이 풀어봐야 할 것 같고, 로직에 오류가 없는지 꼼꼼하게 확인해보자.

## 4번
