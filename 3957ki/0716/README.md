## 1번

각 조합을 2행으로 구성된 2차원 배열로 만들었다.
각 경우의 수 마다, 해당 조합이 없으면 1씩 카운트했다.
하지만 시간초과로 실패했다.

- 3중 for문을 사용해서 중복되지 않도록 아이스크림 3가지를 고른다.
- 피해야 할 조합을 2차원 boolean 배열로 미리 만들어 둔다.
- 만들어진 조합이 피해야 할 조합에 해당하지 않는다면 count한다.

인접행렬을 활용해서 풀어보았다.
무작정 방문여부를 확인하는 배열을 사용해서 접근했었는데, 다른 방식의 접근법을 익힐 필요성을 느꼈다.
앞으로도 이러한 문제가 나오면, 비슷한 방법으로 접근하는 사고력을 키워야겠다.

## 2번
- 큐를 사용한 BFS로 풀어보았다.
- x, y 좌표 값을 가지는 노드를 만들어서 해결했다.

주의할 점은 큐에 삽입할 때 방문 표시를 하는 것이다.
기존에 그렇게 하지 않아서 메모리 오버플로우가 나왔다.
이러한 유형의 문제가 어려워 보여서 기피했는데, 막상 해보니 그럴 필요가 없었다.
다양한 BFS 응용문제를 풀어보지 않았어서, 대학에서 배운 BFS미로탐색 방식으로 접근했다.
이 문제는 비슷해서 해결가능했지만 다른 형태로 출제된다면 많이 헤맬 것 같다.
여러 응용문제를 풀 수 있는 능력을 키워야겠다.

## 3번 (아이디어 도움 받음)
- 왼쪽 위 칸을 기준으로 뒤집으면서 차례대로 순회한다.
- 이 때 왼쪽 위 칸이 해당 칸을 지나치면, 더 이상 해당 칸은 뒤집어지지 않는다.
- 왼쪽 위 부터 차례대로 행렬이 다르면 뒤집어 주도록 했고, 다 뒤집었음에도 남은 칸이 서로 다르면 -1을 출력한다.

이 문제는 아이디어가 상당히 중요했다고 생각한다.
스터디원의 아이디어를 듣고 나서는 쉽게 풀 수 있었다.
여러가지의 사고능력 확장이 필요하다고 생각했다.

## 4번
- 백트래킹을 사용해서 풀었다.
- 총 경기 점수의 합이 30이 아니라면 false를 반환.
- 각 경기 매치업 결과를 차례대로 탐색했다.
- 승 무 패 3가지 경우의 수를 모두 탐색했다.
- 각 경기 결과에 해당하는 인덱스의 점수를 감소시켜가면서 가능여부를 판단했다.

처음 스스로 골드문제를 풀었다.
몇 가지 조건만 확인하면되는 쉬운 문제인 줄 알았지만, 여러 반례가 나왔다.
문제를 풀기까지 굉장히 오래 걸렸다.
각 경우의 수에 접근하는 방법에서 많이 고전했다.
다시 처음부터 하나하나 신중하게 생각해서 겨우 풀 수 있었다.
백트래킹과 DFS같은 문제의 응용에 매우 취약하는 점을 알았다.
비슷한 응용문제를 풀어보며 해결방법에 익숙해져야겠다.
