## 1번
- 간단한 반복문으로 구현.
- 뻔과 데기의 횟수를 배열로 만들어서 개수를 증가시켰다.
- 횟수를 추가할 때 마다 다음 사람 번호를 구했고, 조건을 확인했다.
- 조건이 충족되면 모든 루프를 빠져나오고 사람 번호를 출력한다.

매우 간단하게 해결한 문제였다.
시간초과를 걱정했지만 무난하게 통과했다.

## 2번
- BFS로 각 개체의 개수를 구했다.
- 먼저 RGB값의 평균값을 받아오고, 기준 값보다 큰지 작은지를 판단하여 표시되는 픽셀만 1로 표시했다.
- 배열을 순회하며 1을 만날 때 마다 BFS를 통해 인접한 픽셀을 모두 반복처리하고, 개체수를 1 증가했다.

보자마자 풀이방법이 떠올랐고 빠르게 BFS를 구현하여 문제를 풀 수 있었다.
BFS 알고리즘에는 어느정도 자신감이 생겼다.

## 3번
- DFS로 해결하려했으나, 조금 변칙적으로 해결하게되었다.
- 각 날짜를 배열로 만들고, 날짜별 떡의 종류를 배열 속 List로 저장했다.
- 떡의 종류를 모두 탐색하며 방문하지 않았고, 전날에 먹은 떡의 종류와 같지 않으며, 해당 날짜에 탐색하고있는 떡이 있다면 방문 처리하고 결과 배열에 저장 후 다음 날짜로 재귀했다.
- 재귀할 때, 전날 먹은 떡의 종류를 인자 값으로 전달했다.
- 마지막 날짜까지 모두 떡을 줄 수 있다면, 결과 배열을 출력했다.

일반적인 DFS로 풀었다면 시간초과가 나왔을 것이다.
하지만, 실수로 방문처리를 해제하는 모드를 작성하지 않았는데 오히려 시간 단축에 도움이 되었다.
특정 날짜에 먹을 수 있는 떡이 없다면, 지나온 날짜들의 떡의 종류에 상관없이 전날 먹은 떡을 먹으면 안된다.
그래서 방문처리를 해제하며 DFS를 진행했다면, 전날 먹은 떡의 종류는 변하지 않고 지나온 날들에서 먹은 떡의 종류도 다시 탐색하게된다.
결과적으로 방문처리를 해제할 필요는 없고, 전날 다른 종류의 떡을 먹을 수 있는 경우의 수만 찾으면 문제는 해결할 수 있다.
DP로 접근하여 제대로 된 풀이를 익힐 필요가 있다고 생각했다.

## 4번
- DFS를 2회 진행하여 판을 쌓는 경우의 수와 각 판을 돌리는 경우의 수를 구하고, 그 때 마다 3차원 BFS를 통해 최단거리를 구했다.
- 판을 회전하는 경우의 수는 1개의 판을 고정시켜두고 계산했고, 해당 경우의 수를 바탕으로 새로운 큐브를 만들어갔다.
- BFS를 진행할 때 해당 조각까지의 최단거리를 저장하는 배열을 하나 만들어서 구했다.

구현양이 엄청 많다고 생각한다.
판을 쌓는 경우의 수를 구할 때 마다, 회전하는 경우를 매번 다시 탐색했는데 그럴 필요가 없었다.
회전하는 경우는 판을 쌓는 순서에 관계없이 정해져있으므로, 매번 다시 탐색할 이유가 없다.
그리고 출발지점 4가지를 탐색하는 코드를 반복문으로 처리했다면 더 좋았을 것 같다.
해당 큐브는 크기가 5x5x5로 작게 정해져있으므로 패딩보다는 경계값 처리를 하는 것이 더 효율적일 것이다.
시간내에 풀지는 못했지만 많이 생각해보며 풀 수 있어서 좋았다.
