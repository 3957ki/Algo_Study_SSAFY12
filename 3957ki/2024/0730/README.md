## 1번
- DP를 이용해서 쉽게 풀었다.
- 처음에 DP함수 호출 시작 파라미터를 n으로 하고 재귀로 풀었더니 시간초과가 나왔다.
- 그래서 반복문으로 처음 숫자부터 n까지 차례대로 갱신하여 해결했다.

DP문제에 많이 취약하다는 것을 알게되었고, 같은 유형의 문제를 많이 풀어서 익숙해져야겠다고 생각했다.

## 2번(도움 받음)
- DP를 이용해서 풀었다.
- 처음에 DP값에 자신을 포함하지 않아도 최대값이 되는 수를 저장했다.
- 그랬더니 반례가 있었고 그 반례를 알아내지 못하여서 많이 헤맸다.
- DP값에 무조건 자신을 포함하는 최대값으로 저장했고, 따로 max변수를 두어서 그 값들 중 max값을 저장했다.

DP값에 무엇을 넣어야하는지 알아내는 것이 어려웠다.
조건에 맞춰 점화식을 명확하게 세울 필요성이 있었고, 여러가지 반례를 떠올리는 것이 중요했다.
DP유형에서 많이 고전해서 기본적인 문제부터 차례차례 많이 풀어봐야겠다.

## 3번(일부 도움 받음)
- DFS와 BFS 모두 사용하여 해결했다.
- 주어진 map 테두리를 1로 패딩하여 벽을 만들었고, 2값을 받아 올 때 마다 virus리스트에 저장했다.
- virus 리스트 중 가능한 조합을 DFS로 탐색했고, 탐색한 값을 이용해서 BFS로 4방탐색을 진행했다.
- BFS 과정에서 해당 노드까지 소요되는 시간을 배열로 저장했고, 탐색하지 않은 빈 공간이 있을경우 바로 return했다.
- 모든 빈 공간을 탐색했다면, 소요되는 시간 중 max값을 result값과 비교해서 최소값을 result에 저장했다.
- 각 조합별 소요시간 중 최소 시간을 구할 수 있다.

구현양이 생각보다 많고, DFS에 익숙하지 않아서 오래걸렸다.
일부 테스트 케이스에서 많이 오류가 났다.
놓친 예외 중 하나는, 각 위치별 전파 소요시간을 제대로 저장하지 못했다.
탐색한 위치에 탐색 기준 위치의 값 + 1을 해주는 방식으로 해결했다.
그리고 나머지 예외 하나는, 바이러스 위치 조합을 구했을 때 조합으로 선정되지 않은 바이러스 후보 위치를 간과했다.
조합에 선정되지 않은 위치도 빈 공간으로 인식해서 탐색하는 코드로 수정해서 풀 수 있었다.
DFS 문제를 많이 풀어봐야 할 것 같고, 로직에 오류가 없는지 꼼꼼하게 확인해보자.

## 4번
- DFS를 통해 0으로 만들 번호 조합을 탐색하고, 위상 정렬을 통해 최소 소요시간을 구했다.
- 임시 배열을 만들고, 각 조합에 해당하는 번호의 소요시간을 0으로 만든 후 위상정렬을 반복했다.
- DFS로 찾은 조합을 ArrayDeque으로 저장해서 사용했다.
- 처음 상태에서 위상정렬을 한번해서 마지막에 실행되는 번호를 구한다.
- 조합 별로 소요시간과 임시배열을 매번 다시만들어서 위상정렬을 반복해서 비효율적이다.

DFS로 조합을 구하는 것은 쉽게 할 수 있었지만, 해당조합을 바탕으로 위상정렬을 반복하는 것이 어려웠다.
위상정렬을 한번만하고 DFS 결과에 따라 최소시간을 찾는 방법이 생각이 나지 않아서, 매번 배열을 다시만들어서 정렬을하며 답을 구했다.
가까스로 통과는했지만, 시간이 매우오래걸려서 다른방법을 찾아봐야겠다.
