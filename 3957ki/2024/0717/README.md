## 1번 (도움 받음)

- 조합할 숫자 배열을 오름차순으로 정렬한다.
- DFS를 사용해서 만들어 질 수 있는 경우의 수를 구한다.
- 만들어진 숫자는 N이 넘지 않도록 하고, 최대값을 갱신하면서 계산했다.

처음에는 매우 간단한 문제처럼 생각하며 문자열로 하나하나 접근했다.
하지만 숫자231 처럼 생각하지 못한 반례가 있었다.
DFS로 접근할 생각을 못했었다.
쉬워보여도 꼼꼼하게 생각해보고 여러가지 방법을 유추해보자.

## 2번
- 높은 팁일수록 손실을 적게하여 받아야 가장 많은 금액을 벌 수 있다고 생각했다.
- 팁 배열에 -1을 곱하여 오름차순 정렬하면 내림차순이 된다.
- 값이 int범위를 넘어가므로 long으로 선언한다.

내림차순으로 정렬하는 메서드를 몰라서 -1을 곱하여 풀었다.
Arrays.sort(array, Collections.reverseOrder()); 앞으로는 이 코드를 사용해보자.
하지만 원시타입 배열은 사용할 수 없다.
꼭 Wrapper 타입 배열로 만들어서 사용하자.

처음엔 long으로 선언하지않아서 오류를 찾는데 시간이 많이 걸렸다.
항상 값의 범위를 생각하며 풀어야겠다.

## 3번 (실수한 부분 도움 받음)
- 여러번의 중첩 for문으로 굉장히 복잡하게 풀었다.
- 방문 배열을 만들어서 방문여부를 확인했고, 꽃이 차지하는 모든 부분을 방문처리했다.
- 다음 꽃의 위치는 펼쳐졌을 때 겹쳐지지 않는 위치로 이동하며 탐색했다.
- 3개의 꽃이 배치될 때 마다, 최소값을 갱신했다.

너무 많은 반복문을 사용하여 굉장히 힘들었다.
재귀를 사용하거나 더 효율적인 코드를 만들 수 있을 것 같아서 아쉬움이 남는다.
그리고 다음 꽃의 위치를 탐색할 때, 한 행을 탐색했으면 다음 행의 첫 번째 인덱스로 이동하는 점이 중요했다.
이 점을 놓쳐서 자꾸 실패했다.
기본적으로 다음 행의 첫 번째 위치로 이동하도록 하고, 기존 탐색 위치와 겹치는 부분은 예외처리를 해주는 방식을 사용했다.
다양한 응용문제를 풀어보며 다른 풀이 방법을 익혀보자.

## 4번 (아이디어 일부 도움 받음)

- 각 알파벳 별 개수가 같은지 확인하고 다르면 -1을 출력하고 끝낸다.
- 알파벳 배열을 만들고 증감연산을 통해 구했다.
- B문자열의 오른쪽 부터 시작해서, 문자 순서가 A문자열에서도 가능한 지 알아본다.
- 문자와 문자사이에 다른문자가 얼마든지 있어도 상관없으며, 해당 문자 순서가 애초에 가능한 지를 본다.
- 불가능한 시점을 찾으면 그 시점으로 부터 남은 B문자열의 문자 수가 정답이다.

어떻게 풀어야 할 지 생각이 안났는데, 스터디원의 아이디어 제공으로 풀 수 있었다.
전혀 생각을 못한 방법이라 많이 헤맸다.
창의적인 아이디어와 근본적인 원리를 파악하는 것이 중요하다고 생각했다.
다른 문제에서도 아이디어를 떠올릴 수 있도록 연습하는 것이 필요하다.
