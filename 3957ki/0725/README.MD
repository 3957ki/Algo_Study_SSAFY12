## 1번
- 정렬을 사용한 쉬운 문제.
- 배열을 정렬한 후, 먹을 수 없을 때 까지 먹이를 먹고 길이를 출력한다.
- 먹이를 먹을 때 마다 길이를 1씩 증가시켰다.

이 문제는 엄청 빨리 풀었다.
처음에는 먹이를 순서대로 지나치면서 먹을 수 있는 것만 먹는 조건인줄 알았다.
하지만 지나친 먹이도 길이가 늘어나면 다시 먹을 수 있었고, 정렬을 통해 해결했다.
문제를 꼼꼼하게 보자.

## 2번
- 간단한 BFS로 풀었다.
- 친구의 친구까지만 결혼식에 부를 수 있어서, 깊이 탐색할 필요가 없었다.
- 인접 리스트로 친구관계를 저장하고 visited 배열로 방문표시를 했다.
- 주인공과 친구인 사람들을 모두 큐에 삽입하고 개수를 더한다.
- 그리고 큐에서 값을 빼면서 그 사람과 친구인 사람들 모두 값을 더해줬고, 큐에는 다시 넣지 않았다.

인접리스트를 사용해서 친구관계를 나타내었는데, 다음에는 이중리스트로도 구현해보아야겠다.
생각보다 간단하게 풀었다.

## 3번 (DP 아이디어 도움 받음)
- 완전탐색으로 구현했으나 시간초과로 1차 실패했었다.
- DP를 사용해서 해결했다.
- array 배열을 입력받고 DP배열을 같은크기로 하나 더 만들었다.
- DP배열의 1행과 1열에는 array값이 0이면 1, 0이 아니면 0으로 초기화했다.
- 남은 DP배열을 차례대로 순회하면서 기준칸의 위, 왼쪽, 왼쪽위 방향의 값 중 최소값으로 갱신해 나갔다.
- 갱신하는 값 중 가장 큰 값이 만들 수 있는 가장 큰 정사각형이다.

갱신하는 DP칸은 정사각형의 오른쪽 아래 모서리 칸을 의미한다.
그 기준 칸에서 위, 왼쪽, 왼쪽위 방향의 칸의 값의 최소값이 1이라면, 기준 칸까지의 정사각형 크기는 2임이 보장된다.
마찬가지로 기준 칸에서 탐색한 칸의 최소값이 2라면, 기준 칸 까지의 정사각형 크기는 3임이 보장된다.
이를 계속 반복하여 정사각형의 최대 크기를 구했다.
문제를 풀 때 DP를 사용할 생각을 전혀 못했다.
오른쪽 아래칸을 기준칸으로 사용한 아이디어가 좋았던거 같다.
DP문제는 정말 어려운거 같다.
다양한 사고를 통해 문제 해결능력을 키워야겠다.

## 4번
