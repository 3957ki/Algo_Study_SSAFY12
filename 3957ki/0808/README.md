## 1번
- DFS로 각 도시를 방문할 순서의 경우의 수 중에서 최소비용을 구했다.
- 방문한 도시가 아니고, 비용이 0이 아니며, 처음 도시로 돌아오는 것이 아닐 때 탐색을 이어갔다.
- N개의 도시를 다 방문했지만 처음 도시로 갈 수 없다면 패스하고, 아니라면 최소 비용을 갱신했다.

처음에는 출발하는 처음 도시위치도 1부터 N까지 변경해가며 풀었지만, 그럴필요가 없었다.
다른 도시에서 출발을 하면 비용이 달라질 줄 알았지만, 최소비용은 어디서 출발을 하든지 변함이 없다.
조금 더 깊이 생각해보고 중복되는 경우는 피하도록 하자.

## 2번
- Set 자료구조를 사용하여, 이전 곡의 볼륨의 모든 경우의 수에 따라 다음곡에서 가능한 볼륨을 저장했다.
- N이 1이면 바로 가능한 최대값을 출력하고 종료했다.
- 이전 곡 볼륨의 경우의 수를 기준으로 가능한 경우의 수를 삽입해나갔다.
- 마지막 곡이라면 가능한 최대값을 저장하고 출력했다.

처음엔 list로 구현했었는데 시간초과가 났다.
경우의 수가 기하급수적으로 늘어나다보니 Set을 사용하면 일정범위 이내로 제한이 되었다.
마지막 곡일 때 최대값을 찾는 과정이 조금은 비효율적이다.
Set에서 최대값을 구하는 메서드도 없었고, Set의 각 요소에 접근하는 방법도 몰라서 이렇게 했다.
찾아본 결과, 자바의 foreach문을 사용하면 가능했었다.
아니면 다시 배열로 만드는 방법도 있다.
마지막에 N에 해당하는 Set에서 foreach문을 사용해 최대값을 구하는 것이 더 효율적일 것이다.

## 3번
- BFS로 해결했다.
- 빈 공간에서 BFS를 시작해, 치즈를 만나면 방문처리를하고 치즈 크기를 증가 후 값을 0으로 변경했다.
- 찾은 치즈가 있다면 날짜 증가 후 치즈 크기를 저장했다.
- 찾은 치즈가 없을 때 까지 반복하고, 걸린 날짜와 마지막에 찾은 치즈 크기를 출력했다.

처음에는 경계값 처리를 하지않고 바깥 테두리를 벽이라고 생각하고 문제에 접근했다.
하지만 그렇게하면 벽에 붙어있는 치즈는 탐색을 못하게된다.
원래는 벽이 아니라 빈 공간이기 때문에 해당 치즈도 탐색을 해야한다.
그래서 경계값 처리를 통해 다시 수정하여 통과했다.
그리고 매번 이미 탐색한 빈 공간도 다시 탐색하게되어서 비효율적이다.
방문배열을 따로 두어서, 탐색하지 않은 빈 공간에서부터 탐색을 하면 더 좋을 것 같다.
그래프 탐색시 무지성 패딩으로 해결하는것을 자제해야겠다.

## 4번
- 맨 아래 왼쪽 칸에서 부터 자신의 자리를 포함한 9방 탐색으로 BFS했다.
- 각 노드는 depth값을 가지고 있고, 이는 해당 위치까지 이동한 시간을 의미한다.
- BFS의 장점으로 같은 depth에 갈 수 있는 모든 위치를 차례대로 저장할 수 있다.
- time변수를 두어서, 큐에서 얻은 depth가 증가했다면 벽을 한 칸씩 아래로 이동시켰다.
- 탐색한 위치가 .이고 바로 윗 칸이 #이 아니면 이동가능하다.
- 8초가 지나거나 최상위층에 도달하면 벽이 없어지므로, 목적지까지 이동이 가능하다.

생각보다 4번문제였지만 난이도가 크게 어렵지 않았던 것 같다.
비교적 빨리 풀 수 있었지만, Node 클래스 생성자 부분에 실수를 했다.
depth 파라미터를 필드값에 저장을 안해서 무한루프에 한번 빠졌었다.
앞으로 꼼꼼하게 코드를 작성해야할 필요성을 느꼈다.
