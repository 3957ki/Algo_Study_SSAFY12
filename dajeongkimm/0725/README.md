# 문제 요약

### 1번

정렬

### 2번

BFS (루트 트리로부터 길이가 2이하인 모든 노드의 갯수 구하기)

### 3번

DP
(배열의 값이 0일때, 왼쪽 대각선 위, 위, 왼쪽의 값을 확인하여 최솟값+1을 한 dp 배열 중 최댓값 구하기)

### 4번

BFS, 구현

# TIL

### 1번

### 2번

### 3번

첫번째 열과 행은 배열의 값과 관계없이 dp의 값을 1로 줬더니 실패가 떴다.
첫번째 열과 행도 배열의 값을 고려하여 0일때만 dp의 값을 1로 줘야 정확한 결과값을 얻을 수 있었다.

### 4번

첫 시도에서 가장 큰 블록을 찾기 위해 BFS를 도는 과정에서 블록의 최대 개수가 정확히 파악되지 않는 문제가 있었다.
--> 무지개색은 여러 블록에 포함될 수 있기 때문에 따로 visited 배열을 써서
총 2가지의 방문 배열을 사용해야 한다.

두 번째 시도에서도 bfs 내에서 무지개 블록의 개수를 구하는 과정에서 중간에 업데이트 되는 값을 queue 내에 전달해서 업데이트해서 잘못된 값을 저장했다.
무지개 블록이 발견되는 곳이 bfs 내의 탐색에서 같은 레벨에 속한다면 서로의 값이 업데이트 되지 않은 상태로 각각의 상태를 max 비교를 통해 업데이트 하게된다.
따라서 이와 같은 경우에는 변수를 선언한 뒤 그 값에 +1을 하는 과정을 통해 구해야한다!!!!
